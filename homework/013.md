# Backups

## 1. Подготовка базы данных и таблиц

```sql
-- Создаем базу данных для работы
CREATE DATABASE backup_demo;

-- Создаем первую таблицу
CREATE TABLE table1
(
    id           SERIAL PRIMARY KEY,
    name         VARCHAR(100),
    email        VARCHAR(100),
    created_date TIMESTAMP DEFAULT NOW()
);

-- Создаем вторую таблицу
CREATE TABLE table2
(
    id           SERIAL PRIMARY KEY,
    product_name VARCHAR(100),
    price        DECIMAL(10, 2),
    quantity     INTEGER,
    created_date TIMESTAMP DEFAULT NOW()
);

-- Заполняем таблицы автосгенерированными данными (по 100 записей)
INSERT INTO table1 (name, email)
SELECT 'User_' || seq,
       'user_' || seq || '@example.com'
FROM generate_series(1, 100) as seq;

INSERT INTO table2 (product_name, price, quantity)
SELECT 'Product_' || seq,
       (random() * 1000)::DECIMAL(10, 2),
       (random() * 100)::INTEGER
FROM generate_series(1, 100) as seq;

-- Проверяем данные
SELECT COUNT(*)
FROM table1; -- 100
SELECT COUNT(*)
FROM table2; -- 100
```

## 2. Создание каталога для бэкапов

```shell
# Переключаемся на пользователя postgres
sudo -i -u postgres

# Создаем каталог для бэкапов
mkdir -p  ~/postgresql-backups
chmod 700 ~/postgresql-backups

# Проверяем создание каталога
ls -la ~/postgresql-backups
# total 0
# drwx------  2 postgres  daemon   64  5 ноя 13:17 .
# drwxr-xr-x@ 4 postgres  daemon  128  5 ноя 13:17 ..
```

## 3. Логический бэкап с помощью утилиты COPY
```sql
-- Входим в базу данных
\c backup_demo

-- Создаем бэкап первой таблицы с помощью COPY
COPY table1 TO '/Library/PostgreSQL/16/postgresql-backups/table1_backup.csv' WITH CSV HEADER;

-- Создаем бэкап второй таблицы с помощью COPY
COPY table2 TO '/Library/PostgreSQL/16/postgresql-backups/table2_backup.csv' WITH CSV HEADER;
```

```shell
## Проверяем созданные файлы
ls -la /Library/PostgreSQL/16/postgresql-backups/*.csv

# MacBook-Pro-fpawel:~ postgres$ ls -la /Library/PostgreSQL/16/postgresql-backups/*.csv
# -rw-r--r--@ 1 fpawel  daemon  5803  5 ноя 13:22 /Library/PostgreSQL/16/postgresql-backups/table1_backup.csv
# -rw-r--r--@ 1 fpawel  daemon  5108  5 ноя 13:22 /Library/PostgreSQL/16/postgresql-backups/table2_backup.csv
```

## 4. Восстановление во вторую таблицу из бэкапа

```sql
-- Создаем временную таблицу для восстановления (аналогичную table2)
CREATE TABLE table2_restored (
    id SERIAL PRIMARY KEY,
    product_name VARCHAR(100),
    price DECIMAL(10,2),
    quantity INTEGER,
    created_date TIMESTAMP DEFAULT NOW()
);

-- Восстанавливаем данные из CSV файла
COPY table2_restored FROM '/Library/PostgreSQL/16/postgresql-backups/table2_backup.csv' WITH CSV HEADER;

-- Проверяем восстановленные данные
SELECT COUNT(*) FROM table2_restored; -- 100
SELECT * FROM table2_restored LIMIT 5;
-- +--+------------+------+--------+--------------------------+
-- |id|product_name|price |quantity|created_date              |
-- +--+------------+------+--------+--------------------------+
-- |1 |Product_1   |80.59 |80      |2025-11-05 10:11:33.051161|
-- |2 |Product_2   |409.51|37      |2025-11-05 10:11:33.051161|
-- |3 |Product_3   |505.06|27      |2025-11-05 10:11:33.051161|
-- |4 |Product_4   |707.08|98      |2025-11-05 10:11:33.051161|
-- |5 |Product_5   |912.45|94      |2025-11-05 10:11:33.051161|
-- +--+------------+------+--------+--------------------------+

```

## 5. Бэкап с помощью pg_dump в кастомном сжатом формате

```shell
# Создаем бэкап двух таблиц в кастомном сжатом формате
pg_dump -d backup_demo -t table1 -t table2 -F c -Z 9 -f /Library/PostgreSQL/16/postgresql-backups/tables_backup.custom

# Проверяем созданный файл
ls -la /Library/PostgreSQL/16/postgresql-backups/tables_backup.custom
# -rw-r--r--@ 1 postgres  daemon  6535  5 ноя 13:32 /Library/PostgreSQL/16/postgresql-backups/tables_backup.custom
```

## 6. Восстановление только второй таблицы в новую БД

```sql
-- Создаем новую базу данных для восстановления
CREATE DATABASE restored_db;
```

```shell
# Восстанавливаем только таблицу table2 в новую базу данных
pg_restore -d restored_db -t table2 /Library/PostgreSQL/16/postgresql-backups/tables_backup.custom

# Проверяем восстановление
psql -d restored_db -c "SELECT COUNT(*) FROM table2;"
  count 
  -------
     100
  (1 row)
psql -d restored_db -c "\dt"
         List of relations
 Schema |  Name  | Type  |  Owner   
--------+--------+-------+----------
 public | table2 | table | postgres
(1 row)

```

## 7. Проверка результатов
```shell
## -- Проверяем все созданные базы данных
postgres=# \list
                                               List of databases
    Name     |  Owner   | Encoding | Locale Provider | Collate | Ctype | Locale | ICU Rules | Access privileges 
-------------+----------+----------+-----------------+---------+-------+--------+-----------+-------------------
 backup_demo | postgres | UTF8     | libc            | C       | C     |        |           | 
 maildb      | postgres | UTF8     | libc            | C       | C     |        |           | 
 mydb        | postgres | UTF8     | libc            | C       | C     |        |           | 
 postgres    | fpawel   | UTF8     | libc            | C       | C     |        |           | 
 restored_db | postgres | UTF8     | libc            | C       | C     |        |           | 
 template0   | fpawel   | UTF8     | libc            | C       | C     |        |           | =c/fpawel        +
             |          |          |                 |         |       |        |           | fpawel=CTc/fpawel
 template1   | fpawel   | UTF8     | libc            | C       | C     |        |           | =c/fpawel        +
             |          |          |                 |         |       |        |           | fpawel=CTc/fpawel
(7 rows)

-- Проверяем восстановленные данные в новой базе
postgres=# \c restored_db
You are now connected to database "restored_db" as user "postgres".
```


```sql
SELECT COUNT(*) as restored_count FROM table2; -- 100
SELECT * FROM table2 LIMIT 5;
-- +--+------------+------+--------+--------------------------+
-- |id|product_name|price |quantity|created_date              |
-- +--+------------+------+--------+--------------------------+
-- |1 |Product_1   |80.59 |80      |2025-11-05 10:11:33.051161|
-- |2 |Product_2   |409.51|37      |2025-11-05 10:11:33.051161|
-- |3 |Product_3   |505.06|27      |2025-11-05 10:11:33.051161|
-- |4 |Product_4   |707.08|98      |2025-11-05 10:11:33.051161|
-- |5 |Product_5   |912.45|94      |2025-11-05 10:11:33.051161|
-- +--+------------+------+--------+--------------------------+
```

```shell
-- Возвращаемся в исходную базу и проверяем table2_restored
restored_db=# \c backup_demo
You are now connected to database "backup_demo" as user "postgres".
mydb=# SELECT COUNT(*) as csv_restored_count FROM table2_restored;
 csv_restored_count 
--------------------
                100
(1 row)

backup_demo=# 

```

## Дополнительные проверки и очистка

```sql
-- Сравниваем количество записей в оригинальной и восстановленной таблицах
\c backup_demo
SELECT 'Original table2' as source, COUNT(*) as count FROM table2
UNION ALL
SELECT 'CSV restored' as source, COUNT(*) as count FROM table2_restored;
-- source      | count 
-- -----------------+-------
--  Original table2 |   100
--  CSV restored    |   100
-- (2 rows)


\c restored_db
-- You are now connected to database "restored_db" as user "postgres".
SELECT 'pg_restore table2' as source, COUNT(*) as count FROM table2;
-- restored_db=# SELECT 'pg_restore table2' as source, COUNT(*) as count FROM table2;
-- source       | count 
-- -------------------+-------
--  pg_restore table2 |   100
-- (1 row)


-- Очистка
-- DROP DATABASE IF EXISTS restored_db;
-- DROP DATABASE IF EXISTS backup_demo;
```