# Работа с join'ами, статистикой

## Прямое и левостороннее соединение

Примеры прямого и левостороннего соединение двух (`users` + `orders`), и трёх (`users` + `orders` + `products`) таблиц 

```sql
CREATE TABLE users
(
    id   SERIAL PRIMARY KEY,
    name TEXT NOT NULL
);

CREATE TABLE orders
(
    id      SERIAL PRIMARY KEY,
    user_id INT REFERENCES users (id),
    amount  NUMERIC NOT NULL
);

CREATE TABLE products
(
    id           SERIAL PRIMARY KEY,
    order_id     INT REFERENCES orders (id),
    product_name TEXT NOT NULL
);

INSERT INTO users (name)
VALUES ('Иван'),
       ('Мария'),
       ('Алексей'),
       ('Ольга');

INSERT INTO orders (user_id, amount)
VALUES (1, 100.50),
       (1, 250.00),
       (2, 75.00),
       (3, 300.00);

INSERT INTO products (order_id, product_name)
VALUES (1, 'Ноутбук'),
       (1, 'Мышь'),
       (2, 'Клавиатура'),
       (3, 'Монитор'),
       (4, 'Принтер');

-- Соединение двух таблиц (users + orders)
SELECT u.id AS user_id,
       u.name,
       o.id AS order_id,
       o.amount
FROM users u
         JOIN orders o ON u.id = o.user_id;
-- +-------+-------+--------+------+
-- |user_id|name   |order_id|amount|
-- +-------+-------+--------+------+
-- |1      |Иван   |1       |100.5 |
-- |1      |Иван   |2       |250   |
-- |2      |Мария  |3       |75    |
-- |3      |Алексей|4       |300   |
-- +-------+-------+--------+------+

-- Соединение трёх таблиц (users + orders + products)
SELECT u.id AS user_id,
       u.name,
       o.id AS order_id,
       o.amount,
       p.product_name
FROM users u
         JOIN orders o ON u.id = o.user_id
         JOIN products p ON o.id = p.order_id;
-- +-------+-------+--------+------+------------+
-- |user_id|name   |order_id|amount|product_name|
-- +-------+-------+--------+------+------------+
-- |1      |Иван   |1       |100.5 |Ноутбук     |
-- |1      |Иван   |1       |100.5 |Мышь        |
-- |1      |Иван   |2       |250   |Клавиатура  |
-- |2      |Мария  |3       |75    |Монитор     |
-- |3      |Алексей|4       |300   |Принтер     |
-- +-------+-------+--------+------+------------+

-- LEFT JOIN (если нужны пользователи без заказов)
SELECT u.id AS user_id,
       u.name,
       o.id AS order_id,
       o.amount
FROM users u
         LEFT JOIN orders o ON u.id = o.user_id;
-- +-------+-------+--------+------+
-- |user_id|name   |order_id|amount|
-- +-------+-------+--------+------+
-- |1      |Иван   |1       |100.5 |
-- |1      |Иван   |2       |250   |
-- |2      |Мария  |3       |75    |
-- |3      |Алексей|4       |300   |
-- |4      |Ольга  |null    |null  |
-- +-------+-------+--------+------+
```

## Кросс соединение двух и трёх таблиц

```sql
CREATE TABLE colors
(
    id   SERIAL PRIMARY KEY,
    name TEXT
);

CREATE TABLE sizes
(
    id    SERIAL PRIMARY KEY,
    label TEXT
);

INSERT INTO colors (name)
VALUES ('Красный'),
       ('Зелёный'),
       ('Синий');

INSERT INTO sizes (label)
VALUES ('S'),
       ('M'),
       ('L');

-- Теперь сделаем CROSS JOIN:
SELECT c.name AS color, s.label AS size
FROM colors c
         CROSS JOIN sizes s;
--Результат: 3 цвета × 3 размера = 9 строк.
-- +-------+----+
-- |color  |size|
-- +-------+----+
-- |Красный|S   |
-- |Красный|M   |
-- |Красный|L   |
-- |Зелёный|S   |
-- |Зелёный|M   |
-- |Зелёный|L   |
-- |Синий  |S   |
-- |Синий  |M   |
-- |Синий  |L   |
-- +-------+----+

-- Добавим таблицу materials:
CREATE TABLE materials
(
    id   SERIAL PRIMARY KEY,
    name TEXT
);

INSERT INTO materials (name)
VALUES ('Хлопок'),
       ('Шерсть');

-- Кросс-соединение трёх таблиц:
SELECT c.name  AS color,
       s.label AS size,
       m.name  AS material
FROM colors c
         CROSS JOIN sizes s
         CROSS JOIN materials m;

-- Результат: 3 цвета × 3 размера × 2 материала = 18 строк.
-- +-------+----+--------+
-- |color  |size|material|
-- +-------+----+--------+
-- |Красный|S   |Хлопок  |
-- |Красный|S   |Шерсть  |
-- |Красный|M   |Хлопок  |
-- |Красный|M   |Шерсть  |
-- |Красный|L   |Хлопок  |
-- |Красный|L   |Шерсть  |
-- |Зелёный|S   |Хлопок  |
-- |Зелёный|S   |Шерсть  |
-- |Зелёный|M   |Хлопок  |
-- |Зелёный|M   |Шерсть  |
-- |Зелёный|L   |Хлопок  |
-- |Зелёный|L   |Шерсть  |
-- |Синий  |S   |Хлопок  |
-- |Синий  |S   |Шерсть  |
-- |Синий  |M   |Хлопок  |
-- |Синий  |M   |Шерсть  |
-- |Синий  |L   |Хлопок  |
-- |Синий  |L   |Шерсть  |
-- +-------+----+--------+

-- Сокращённая форма (через ,)
-- В PostgreSQL CROSS JOIN эквивалентен записи через запятую:
SELECT c.name, s.label
FROM colors c, sizes s;
-- +-------+-----+
-- |name   |label|
-- +-------+-----+
-- |Красный|S    |
-- |Красный|M    |
-- |Красный|L    |
-- |Зелёный|S    |
-- |Зелёный|M    |
-- |Зелёный|L    |
-- |Синий  |S    |
-- |Синий  |M    |
-- |Синий  |L    |
-- +-------+-----+
```
## Полное соединение
Это такой тип соединения, который возвращает все строки из обеих таблиц:
- если есть совпадение по условию ON → строки объединяются,
- если нет → недостающие значения заполняются NULL.

```sql
CREATE TABLE customers
(
    id   INT PRIMARY KEY,
    name TEXT
);

CREATE TABLE orders
(
    id          INT PRIMARY KEY,
    customer_id INT,
    product     TEXT
);

INSERT INTO customers
VALUES (1, 'Иван'),
       (2, 'Мария'),
       (3, 'Ольга');

INSERT INTO orders
VALUES (1, 1, 'Ноутбук'),
       (2, 1, 'Мышь'),
       (3, 4, 'Монитор'); -- заказ на несуществующего покупателя
```
Пример с тремя таблицами
```sql
CREATE TABLE payments
(
    id       INT PRIMARY KEY,
    order_id INT,
    amount   NUMERIC
);

INSERT INTO payments
VALUES (1, 1, 1000.00),
       (2, 3, 500.00),
       (3, 5, 750.00); -- платёж на несуществующий заказ

SELECT c.name   AS customer_name,
       o.id     AS order_id,
       o.product,
       p.amount AS payment
FROM customers c
         FULL JOIN orders o
                   ON c.id = o.customer_id
         FULL JOIN payments p
                   ON o.id = p.order_id;
-- Результат:
-- Иван → его заказы + платежи,
-- Мария и Ольга (NULL для заказов и платежей),
-- Заказ от "customer_id=4" (NULL для имени клиента),
-- Платёж на несуществующий заказ (NULL для клиента и заказа).
-- +-------------+--------+-------+-------+
-- |customer_name|order_id|product|payment|
-- +-------------+--------+-------+-------+
-- |Иван         |1       |Ноутбук|1000   |
-- |null         |3       |Монитор|500    |
-- |null         |null    |null   |750    |
-- |Ольга        |null    |null   |null   |
-- |Мария        |null    |null   |null   |
-- |Иван         |2       |Мышь   |null   |
-- +-------------+--------+-------+-------+
```

## Запрос с использованием разных типов соединений

```sql
SELECT c.name    AS customer_name,
       o.product AS product_name,
       p.amount  AS payment_amount
FROM customers c
-- INNER JOIN: берём только тех клиентов, у которых есть заказы
         INNER JOIN orders o
                    ON c.id = o.customer_id
-- LEFT JOIN: добавим платежи, даже если их нет
         LEFT JOIN payments p
                   ON o.id = p.order_id;
-- +-------------+------------+--------------+
-- |customer_name|product_name|payment_amount|
-- +-------------+------------+--------------+
-- |Иван         |Ноутбук     |1000          |
-- |Иван         |Мышь        |null          |
-- +-------------+------------+--------------+
```

##  3 метрики на основе показанных представлений

### Конверсия клиентов в заказы

```sql
SELECT 
    COUNT(DISTINCT o.customer_id)::decimal / COUNT(DISTINCT c.id) AS order_conversion_rate
FROM customers c
LEFT JOIN orders o ON c.id = o.customer_id;
```

### Доля оплаченных заказов

```sql
SELECT 
    COUNT(DISTINCT p.order_id)::decimal / COUNT(DISTINCT o.id) AS paid_order_rate
FROM orders o
LEFT JOIN payments p ON o.id = p.order_id;
```

### Средний чек (средняя сумма платежа на заказ)

```sql
SELECT 
    AVG(p.amount) AS avg_order_payment
FROM orders o
JOIN payments p ON o.id = p.order_id;
```