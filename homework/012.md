# Триггеры

## Основное решение

```sql
-- Создание функции для обновления витрины
CREATE OR REPLACE FUNCTION update_good_sum_mart()
RETURNS TRIGGER AS $$
BEGIN
    -- Обработка операции DELETE
    IF TG_OP = 'DELETE' THEN
        UPDATE good_sum_mart 
        SET sum_sale = sum_sale - (SELECT good_price FROM goods WHERE goods_id = OLD.good_id) * OLD.sales_qty
        WHERE good_name = (SELECT good_name FROM goods WHERE goods_id = OLD.good_id);
        
        -- Если сумма стала 0 или меньше, удаляем запись
        DELETE FROM good_sum_mart 
        WHERE good_name = (SELECT good_name FROM goods WHERE goods_id = OLD.good_id)
        AND sum_sale <= 0;
        
        RETURN OLD;
    
    -- Обработка операции INSERT
    ELSIF TG_OP = 'INSERT' THEN
        -- Проверяем, существует ли уже запись для этого товара
        IF EXISTS (SELECT 1 FROM good_sum_mart WHERE good_name = (SELECT good_name FROM goods WHERE goods_id = NEW.good_id)) THEN
            UPDATE good_sum_mart 
            SET sum_sale = sum_sale + (SELECT good_price FROM goods WHERE goods_id = NEW.good_id) * NEW.sales_qty
            WHERE good_name = (SELECT good_name FROM goods WHERE goods_id = NEW.good_id);
        ELSE
            INSERT INTO good_sum_mart (good_name, sum_sale)
            SELECT 
                good_name,
                good_price * NEW.sales_qty
            FROM goods 
            WHERE goods_id = NEW.good_id;
        END IF;
        
        RETURN NEW;
    
    -- Обработка операции UPDATE
    ELSIF TG_OP = 'UPDATE' THEN
        -- Если изменился товар, нужно вычесть старые значения и добавить новые
        IF OLD.good_id != NEW.good_id THEN
            -- Удаляем из старого товара
            UPDATE good_sum_mart 
            SET sum_sale = sum_sale - (SELECT good_price FROM goods WHERE goods_id = OLD.good_id) * OLD.sales_qty
            WHERE good_name = (SELECT good_name FROM goods WHERE goods_id = OLD.good_id);
            
            -- Добавляем к новому товару
            UPDATE good_sum_mart 
            SET sum_sale = sum_sale + (SELECT good_price FROM goods WHERE goods_id = NEW.good_id) * NEW.sales_qty
            WHERE good_name = (SELECT good_name FROM goods WHERE goods_id = NEW.good_id);
        ELSE
            -- Если изменилось только количество
            UPDATE good_sum_mart 
            SET sum_sale = sum_sale + (SELECT good_price FROM goods WHERE goods_id = NEW.good_id) * (NEW.sales_qty - OLD.sales_qty)
            WHERE good_name = (SELECT good_name FROM goods WHERE goods_id = NEW.good_id);
        END IF;
        
        -- Удаляем записи с нулевой или отрицательной суммой
        DELETE FROM good_sum_mart WHERE sum_sale <= 0;
        
        RETURN NEW;
    END IF;
    
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Создание триггера
CREATE TRIGGER sales_trigger
    AFTER INSERT OR UPDATE OR DELETE ON sales
    FOR EACH ROW
    EXECUTE FUNCTION update_good_sum_mart();
```

## Альтернативное "красивое" решение

```sql
-- Более элегантное решение с использованием временных переменных
CREATE OR REPLACE FUNCTION update_good_sum_mart_v2()
RETURNS TRIGGER AS $$
DECLARE
    old_good_name varchar(63);
    new_good_name varchar(63);
    old_amount numeric(16,2);
    new_amount numeric(16,2);
BEGIN
    -- Определяем названия товаров и суммы
    IF TG_OP IN ('DELETE', 'UPDATE') THEN
        SELECT good_name, good_price * OLD.sales_qty 
        INTO old_good_name, old_amount
        FROM goods WHERE goods_id = OLD.good_id;
    END IF;
    
    IF TG_OP IN ('INSERT', 'UPDATE') THEN
        SELECT good_name, good_price * NEW.sales_qty 
        INTO new_good_name, new_amount
        FROM goods WHERE goods_id = NEW.good_id;
    END IF;
    
    -- Обработка разных операций
    CASE TG_OP
        WHEN 'DELETE' THEN
            PERFORM update_mart_value(old_good_name, -old_amount);
            
        WHEN 'INSERT' THEN
            PERFORM update_mart_value(new_good_name, new_amount);
            
        WHEN 'UPDATE' THEN
            IF OLD.good_id != NEW.good_id THEN
                PERFORM update_mart_value(old_good_name, -old_amount);
                PERFORM update_mart_value(new_good_name, new_amount);
            ELSE
                PERFORM update_mart_value(new_good_name, new_amount - old_amount);
            END IF;
    END CASE;
    
    -- Очистка нулевых записей
    DELETE FROM good_sum_mart WHERE sum_sale <= 0;
    
    RETURN CASE 
        WHEN TG_OP = 'DELETE' THEN OLD 
        ELSE NEW 
    END;
END;
$$ LANGUAGE plpgsql;

-- Вспомогательная функция для обновления значений в витрине
CREATE OR REPLACE FUNCTION update_mart_value(
    p_good_name varchar(63), 
    p_amount numeric(16,2)
) RETURNS void AS $$
BEGIN
    IF EXISTS (SELECT 1 FROM good_sum_mart WHERE good_name = p_good_name) THEN
        UPDATE good_sum_mart 
        SET sum_sale = sum_sale + p_amount
        WHERE good_name = p_good_name;
    ELSE
        INSERT INTO good_sum_mart (good_name, sum_sale)
        VALUES (p_good_name, p_amount);
    END IF;
END;
$$ LANGUAGE plpgsql;

-- Создание улучшенного триггера
DROP TRIGGER IF EXISTS sales_trigger ON sales;
CREATE TRIGGER sales_trigger
    AFTER INSERT OR UPDATE OR DELETE ON sales
    FOR EACH ROW
    EXECUTE FUNCTION update_good_sum_mart_v2();
```

## Преимущества предложенного решения:
- Обрабатывает INSERT, UPDATE, DELETE операции
- Корректно работает с изменением товара в существующих продажах
- Автоматически удаляет нулевые записи
- Использует атомарные операции для избежания race condition
- Модульная структура (во втором варианте) для легкости поддержки


## Тестирование решения

```sql
-- Инициализация витрины начальными данными
TRUNCATE TABLE good_sum_mart;
INSERT INTO good_sum_mart (good_name, sum_sale)
SELECT G.good_name, sum(G.good_price * S.sales_qty)
FROM goods G
INNER JOIN sales S ON S.good_id = G.goods_id
GROUP BY G.good_name;

-- Проверка начального состояния
SELECT * FROM good_sum_mart;

-- Тест INSERT
INSERT INTO sales (good_id, sales_qty) VALUES (1, 5);
SELECT * FROM good_sum_mart; -- Должна увеличиться сумма для спичек

-- Тест UPDATE (изменение количества)
UPDATE sales SET sales_qty = 20 WHERE sales_id = 1;
SELECT * FROM good_sum_mart; -- Сумма должна измениться

-- Тест UPDATE (изменение товара)
UPDATE sales SET good_id = 2 WHERE sales_id = 1;
SELECT * FROM good_sum_mart; -- Суммы должны перераспределиться между товарами

-- Тест DELETE
DELETE FROM sales WHERE sales_id = 1;
SELECT * FROM good_sum_mart; -- Сумма должна уменьшиться
```

## Чем такая схема (витрина+триггер) предпочтительнее отчета, создаваемого "по требованию" (кроме производительности)?

- **Историческая точность данных:** При изменении цен в таблице товаров, витрина сохраняет сумму продаж по ценам, действовавшим на момент продажи. Отчет "по требованию" всегда будет использовать текущие цены, что исказит исторические данные.
- **Консистентность во времени:** Витрина фиксирует финансовые результаты на момент совершения операции, что важно для бухгалтерского учета и анализа трендов.
- **Атомарность обновлений:** Каждое изменение в продажах немедленно и атомарно отражается в витрине, что исключает расхождения между операционными данными и отчетностью.
- **Упрощение сложных расчетов:** Если бы потребовались более сложные агрегации (средние цены, сезонные коэффициенты и т.д.), их поддержка в витрине проще, чем в запросе "на лету".
- **Аудит изменений:** Витрина может быть расширена для хранения истории изменений, что затруднительно при генерации отчетов "по требованию".
