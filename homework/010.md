# Работа с индексами и оптимизация запросов

## Создание базового индекса
Создам индекс для ускорения поиска заказов по статусу, так как этот запрос выполняется часто.

```sql
-- Создаем индекс
CREATE INDEX idx_orders_status ON orders(status);

-- Проверяем работу индекса
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM orders WHERE status = 'completed';
```

Результат EXPLAIN:
```text
Seq Scan on orders  (cost=0.00..1450.00 rows=500 width=136) (actual time=0.012..8.456 rows=1502 loops=1)
Filter: (status = 'completed'::text)
Rows Removed by Filter: 8498
Planning Time: 0.112 ms
Execution Time: 8.612 ms
```

После создания индекса:
```text
Index Scan using idx_orders_status on orders  (cost=0.29..65.57 rows=1502 width=136) (actual time=0.021..0.856 rows=1502 loops=1)
Index Cond: (status = 'completed'::text)
Buffers: shared hit=25
Planning Time: 0.156 ms
Execution Time: 1.012 ms
Вывод: Индекс ускорил запрос в 8.5 раз!
```

## Полнотекстовый поиск
Создам полнотекстовый индекс для поиска по описанию товаров.

```sql
-- Создаем полнотекстовый поиск
ALTER TABLE products ADD COLUMN search_vector tsvector;
UPDATE products SET search_vector = to_tsvector('russian', coalesce(name, '') || ' ' || coalesce(description, ''));
CREATE INDEX idx_products_search ON products USING gin(search_vector);

-- Проверяем работу
EXPLAIN (ANALYZE, BUFFERS)
SELECT name, description
FROM products
WHERE search_vector @@ to_tsquery('russian', 'ноутбук & игровой');
```

Результат EXPLAIN:
```text

Bitmap Heap Scan on products  (cost=28.73..153.45 rows=50 width=64) (actual time=0.245..0.312 rows=23 loops=1)
Recheck Cond: (search_vector @@ to_tsquery('russian'::regconfig, 'ноутбук & игровой'::text))
Heap Blocks: exact=18
Buffers: shared hit=22
->  Bitmap Index Scan on idx_products_search  (cost=0.00..28.72 rows=50 width=0) (actual time=0.234..0.234 rows=23 loops=1)
Index Cond: (search_vector @@ to_tsquery('russian'::regconfig, 'ноутбук & игровой'::text))
Buffers: shared hit=4
Planning Time: 0.135 ms
Execution Time: 0.345 ms
```

## Частичный индекс и индекс с функцией
Создам частичный индекс для активных пользователей и индекс с функцией для поиска по email без учета регистра.

```sql
-- Частичный индекс (только для активных пользователей)
CREATE INDEX idx_users_active ON users(status)
WHERE status = 'active';

-- Индекс с функцией (поиск email без учета регистра)
CREATE INDEX idx_users_email_lower ON users(LOWER(email));

-- Проверяем частичный индекс
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM users
WHERE status = 'active' AND created_at > '2024-01-01';
```

Результат EXPLAIN для частичного индекса:
```text
Index Scan using idx_users_active on users  (cost=0.29..45.82 rows=850 width=92) (actual time=0.015..0.287 rows=756 loops=1)
Index Cond: (status = 'active'::text)
Filter: (created_at > '2024-01-01 00:00:00'::timestamp without time zone)
Buffers: shared hit=18
Planning Time: 0.112 ms
Execution Time: 0.356 ms
```


## Составной индекс
Создам составной индекс для часто используемого запроса поиска заказов по пользователю и дате.

```sql
-- Составной индекс
CREATE INDEX idx_orders_user_date ON orders(user_id, order_date);

-- Проверяем работу
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM orders
WHERE user_id = 12345
AND order_date BETWEEN '2024-01-01' AND '2024-12-31'
ORDER BY order_date DESC;
```

Результат EXPLAIN:

```text
Index Scan using idx_orders_user_date on orders  (cost=0.29..12.87 rows=5 width=136) (actual time=0.018..0.023 rows=8 loops=1)
Index Cond: ((user_id = 12345) AND (order_date >= '2024-01-01'::date) AND (order_date <= '2024-12-31'::date))
Buffers: shared hit=4
Planning Time: 0.156 ms
Execution Time: 0.045 ms
```

## Итоговый скрипт со всеми индексами

```sql
-- 1. Базовый индекс
CREATE INDEX idx_orders_status ON orders(status);

-- 2. Полнотекстовый поиск
ALTER TABLE products ADD COLUMN search_vector tsvector;
UPDATE products SET search_vector = to_tsvector('russian', coalesce(name, '') || ' ' || coalesce(description, ''));
CREATE INDEX idx_products_search ON products USING gin(search_vector);

-- 3. Частичный индекс и индекс с функцией
CREATE INDEX idx_users_active ON users(status) WHERE status = 'active';
CREATE INDEX idx_users_email_lower ON users(LOWER(email));

-- 4. Составной индекс
CREATE INDEX idx_orders_user_date ON orders(user_id, order_date);
```

## Проблемы и решения:
**Проблема**: При создании полнотекстового индекса столкнулся с необходимостью обновления существующих данных
**Решение**: Добавил UPDATE для заполнения search_vector перед созданием индекса

**Проблема**: Частичный индекс не использовался в некоторых запросах
**Решение**: Убедился, что условия в WHERE запроса точно соответствуют условию в частичном индексе

**Проблема**: Составной индекс не всегда используется оптимально
**Решение**: Расположил поля в порядке уменьшения селективности (user_id сначала, так как он более селективен)

## Выводы:
- Индексы значительно ускоряют выполнение запросов (в примере до 8.5 раз)
- Правильное проектирование индексов требует анализа реальных запросов
- Частичные индексы экономят место и ускоряют запросы к подмножеству данных
- Составные индексы эффективны для сложных условий поиска
- Полнотекстовый поиск с GIN-индексами мощный инструмент для текстового поиска