# Механизм блокировок

`Postgresql` настроен так, чтобы в журнал сообщений сбрасывалась информация о блокировках, удерживаемых более 200
миллисекунд.
Воспроизведите ситуацию, при которой в журнале появятся такие сообщения.

```sql
-- log_lock_waits = on — включает запись в журнал, когда процесс ждёт блокировки дольше deadlock_timeout
SHOW log_lock_waits;
-- on

-- deadlock_timeout = 200ms — если ожидание превышает 200 мс, событие пишется в postgresql.log
SHOW deadlock_timeout; -- 200ms
```

## Обновление одной и той же строки в разных сеансах.

```sql
-- Создадим таблицу и одну строку:
CREATE TABLE t_locktest
(
    id  int PRIMARY KEY,
    val text
);
INSERT INTO t_locktest VALUES (1, 'init');

-- Сеанс 1

-- Запускаем транзакцию и обновляем строку, но не делаем COMMIT:

BEGIN;
UPDATE t_locktest SET val = 'from_session1' WHERE id = 1;
-- строка теперь под эксклюзивной блокировкой, транзакция открыта

-- Сеанс 2

-- Пробуем обновить ту же строку:
BEGIN;
UPDATE t_locktest SET val = 'from_session2' WHERE id = 1;
-- команда "подвиснет", ожидая освобождения блокировки от сеанса 1

-- Сеанс 3

-- Аналогично, ещё одна попытка обновить ту же строку:
BEGIN;
UPDATE t_locktest SET val = 'from_session3' WHERE id = 1;
-- тоже встанет в очередь
```

Представление `pg_locks` показывает, кто кого держит и кто ждёт.
Следующий запрос показывает, какие запросы (через pg_stat_activity.query) ждут блокировку и кто их держит.

```sql

-- Сеанс 4

SELECT l.pid,
       a.usename,
       a.query,
       l.locktype,
       l.mode
FROM pg_locks l
         JOIN pg_stat_activity a ON l.pid = a.pid
WHERE  not l.granted
ORDER BY relation, granted DESC;
```

```text
+-----+--------+--------------------------------------------------------+-------------+-------------+
|pid  |usename |query                                                   |locktype     |mode         |
+-----+--------+--------------------------------------------------------+-------------+-------------+
|48315|postgres|UPDATE t_locktest SET val = 'from_session3' WHERE id = 1|tuple        |ExclusiveLock|
|48113|postgres|UPDATE t_locktest SET val = 'from_session2' WHERE id = 1|transactionid|ShareLock    |
+-----+--------+--------------------------------------------------------+-------------+-------------+
```
По результатам в столбце `query` видно какие именно запросы заблокированы.

## Взаимная блокировка трех транзакций.

В `PostgreSQL` классический deadlock воспроизводится, когда несколько транзакций берут ресурсы «крест-накрест».
Для трёх участников это выглядит так:

```sql
-- Сеанс 1

CREATE TABLE t_deadlock (
    id int PRIMARY KEY,
    val text
);

INSERT INTO t_deadlock VALUES (1,'a'),(2,'b'),(3,'c');

BEGIN;
UPDATE t_deadlock SET val = 'x' WHERE id = 1;
-- транзакция держит блокировку на строке id=1

-- Сеанс 2

BEGIN;
UPDATE t_deadlock SET val = 'y' WHERE id = 2;
-- держит блокировку на строке id=2

-- Сеанс 3

BEGIN;
UPDATE t_deadlock SET val = 'z' WHERE id = 3;
-- держит блокировку на строке id=3

-- В Сеансе 1 пробуем обновить строку id=2:
UPDATE t_deadlock SET val = 'x1' WHERE id = 2;

-- В Сеансе 2 пробуем обновить строку id=3:
UPDATE t_deadlock SET val = 'y1' WHERE id = 3;

-- В Сеансе 3 пробуем обновить строку id=1:
UPDATE t_deadlock SET val = 'z1' WHERE id = 1;
-- [40P01] ERROR: deadlock detected
-- Подробности: Process 48315 waits for ShareLock on transaction 29327989; blocked by process 32955.
-- Process 32955 waits for ShareLock on transaction 29327990; blocked by process 48113.
-- Process 48113 waits for ShareLock on transaction 29327986; blocked by process 48315.
-- Подсказка: See server log for query details
```

- `Сеанс 1` держит `id=1`, ждёт `id=2`
- `Сеанс 2 `держит `id=2`, ждёт id=3
- `Сеанс 3` держит `id=3`, ждёт `id=1`
- `PostgreSQL` обнаружил цикл ожиданий и автоматически убил одну транзакцию `Сеанс 3`, выдавая `ERROR: deadlock detected`

Можно разобраться во взаимных блокировках постфактум, изучая журнал сообщений.
Когда срабатывает детектор deadlock, в журнал пишется блок примерно такого вида: 
```text
2025-08-22 13:59:59.170 MSK [48315] ERROR:  deadlock detected
2025-08-22 13:59:59.170 MSK [48315] DETAIL:  Process 48315 waits for ShareLock on transaction 29327989; blocked by process 32955.
	Process 32955 waits for ShareLock on transaction 29327990; blocked by process 48113.
	Process 48113 waits for ShareLock on transaction 29327986; blocked by process 48315.
	Process 48315: UPDATE t_deadlock SET val = 'z1' WHERE id = 1
	Process 32955: UPDATE t_deadlock SET val = 'x1' WHERE id = 2
	Process 48113: UPDATE t_deadlock SET val = 'y1' WHERE id = 3
```
В этом сообщении есть:
- PID процессов (можно соотнести с pg_stat_activity в момент события).
- Типы блокировок (RowExclusiveLock, ShareLock и т. д.).
- Какие транзакции ждут друг друга (цепочка).
- Фрагмент SQL-запроса, который вызвал конфликт.
- В некоторых версиях — даже имя таблицы/отношения.
  
### Ограничения

- В журнале есть факт deadlock и запросы, но не всегда полная картину того, что происходило до этого.
- История предыдущих запросов в транзакции в лог не попадает (только тот, что вызвал тупик).
- Если логи короткие или ротация настроена агрессивно, запись можно потерять

# Могут ли две транзакции, выполняющие единственную команду UPDATE одной и той же таблицы (без where), заблокировать друг друга?

Deadlock невозможен при двух простых UPDATE ... без WHERE, но они могут «закуситься» и держать друг друга долго, пока кто-то не завершит транзакцию.

- При UPDATE ... без WHERE PostgreSQL последовательно читает все строки таблицы и пытается поставить на каждую блокировку.
- Если две транзакции делают это одновременно, то одна из них успевает захватить строку №1, вторая — строку №2.
- Потом первая хочет строку №2, но видит, что она занята второй → ждёт.
- Вторая хочет строку №1, но она занята первой → ждёт.

На первый взгляд это похоже на deadlock, но `PostgreSQL` не блокирует запросы симметрично:
- Планировщик чтения строк идёт последовательно, и одна транзакция начинает ждать на первой же заблокированной строке.
- Вторая в этот момент тоже блокируется, и в итоге обе «висят» до тех пор, пока кто-то не освободит строки.

Это не deadlock, а обычная блокировка (lock contention).

`PostgreSQL` deadlock-детектор работает на уровне транзакций и цепочек ожидания: для взаимоблокировки нужен цикл зависимостей (A ждёт B, а B ждёт A).
В случае UPDATE без WHERE цикл не формируется — оба процесса просто ждут освобождения строк, захваченных другим.
Один из апдейтов будет ждать, пока другой закончит всю таблицу и сделает COMMIT/ROLLBACK.
После этого второй продолжит и успешно обновит строки.
Ошибки deadlock detected не будет, только «подвисание» до завершения первой транзакции.

Ниже сценарий на две сессии, чтобы воспроизвести ситуацию, когда две транзакции делают UPDATE всей таблицы и блокируют 
друг друга на долгое время, но без deadlock.

```sql
-- Сеанс 1

CREATE TABLE t_block
(
    id  int PRIMARY KEY,
    val text
);

INSERT INTO t_block
VALUES (1, 'a'),
       (2, 'b'),
       (3, 'c'),
       (4, 'd');

BEGIN;
UPDATE t_block SET val = 'x';
-- Запрос захватил строки последовательно, например id=1 уже под эксклюзивной блокировкой

-- Сеанс 2

BEGIN;
UPDATE t_block SET val = 'y';
-- Запрос попытается захватить строки в том же порядке,
-- но сразу "встрянет" на первой строке, которая уже занята сеансом 1

-- Сеанс 3

SELECT l.pid, a.usename, a.query, l.mode
FROM pg_locks l
         JOIN pg_stat_activity a ON l.pid = a.pid
WHERE l.relation = 't_block'::regclass
ORDER BY granted DESC;
```
- Сеанс 1 держит RowExclusiveLock на строки.
- Сеанс 2 ждёт (granted = f).
- Если выполнить COMMIT; в сеансе 1 → сеанс 2 продолжит выполнение.
- Если сделать ROLLBACK; в сеансе 1 → то же самое.
