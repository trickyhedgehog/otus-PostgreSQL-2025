# Виды и устройство репликации в PostgreSQL

## Шаг 1: Подготовка виртуальных машин

Создаем 3 ВМ с PostgreSQL 14+:
- VM1 (192.168.1.10) - основной сервер для записи в таблицу test
- VM2 (192.168.1.11) - основной сервер для записи в таблицу test2
- VM3 (192.168.1.12) - реплика для чтения и бэкапов

## Шаг 2: Настройка VM1

```sql
-- Создаем базу данных
CREATE DATABASE replication_db;

-- Подключаемся к базе
\c replication_db

-- Создаем таблицы
CREATE TABLE test (
    id SERIAL PRIMARY KEY,
    data VARCHAR(100),
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE test2 (
    id SERIAL PRIMARY KEY,
    data VARCHAR(100),
    created_at TIMESTAMP DEFAULT NOW()
);

-- Настраиваем параметры репликации в postgresql.conf
-- wal_level = logical
-- max_replication_slots = 10
-- max_wal_senders = 10

-- Настраиваем pg_hba.conf
-- host replication all 192.168.1.0/24 md5
-- host all all 192.168.1.0/24 md5

-- Перезапускаем PostgreSQL
sudo systemctl restart postgresql

-- Создаем публикацию для таблицы test
CREATE PUBLICATION pub_test FOR TABLE test;
```

## Шаг 3: Настройка VM2

```sql
-- Создаем базу данных
CREATE DATABASE replication_db;

-- Подключаемся к базе
\c replication_db

-- Создаем таблицы
CREATE TABLE test (
    id SERIAL PRIMARY KEY,
    data VARCHAR(100),
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE test2 (
    id SERIAL PRIMARY KEY,
    data VARCHAR(100),
    created_at TIMESTAMP DEFAULT NOW()
);

-- Настраиваем параметры репликации (аналогично VM1)

-- Создаем публикацию для таблицы test2
CREATE PUBLICATION pub_test2 FOR TABLE test2;

-- Создаем подписку на таблицу test с VM1
CREATE SUBSCRIPTION sub_test 
CONNECTION 'host=192.168.1.10 port=5432 dbname=replication_db user=postgres password=your_password'
PUBLICATION pub_test;
```

## Шаг 4: Настройка VM1 (продолжение)
```sql
-- Создаем подписку на таблицу test2 с VM2
CREATE SUBSCRIPTION sub_test2
    CONNECTION 'host=192.168.1.11 port=5432 dbname=replication_db user=postgres password=your_password'
    PUBLICATION pub_test2;
```

## Шаг 5: Настройка VM3 (реплика для чтения)

```sql
-- Создаем базу данных
CREATE DATABASE replication_db;

-- Подключаемся к базе
\c replication_db

-- Создаем таблицы (структура должна совпадать)
CREATE TABLE test (
    id SERIAL PRIMARY KEY,
    data VARCHAR(100),
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE test2 (
    id SERIAL PRIMARY KEY,
    data VARCHAR(100),
    created_at TIMESTAMP DEFAULT NOW()
);

-- Создаем подписки на обе таблицы
CREATE SUBSCRIPTION sub_test_from_vm1
CONNECTION 'host=192.168.1.10 port=5432 dbname=replication_db user=postgres password=your_password'
PUBLICATION pub_test;

CREATE SUBSCRIPTION sub_test2_from_vm2
CONNECTION 'host=192.168.1.11 port=5432 dbname=replication_db user=postgres password=your_password'
PUBLICATION pub_test2;
```

## Шаг 6: Тестирование репликации

```sql
-- VM1
INSERT INTO test (data) VALUES ('Data from VM1');

-- VM2
INSERT INTO test2 (data) VALUES ('Data from VM2');

-- На VM3 (проверяем репликацию):
SELECT * FROM test;    -- Должны видеть данные из VM1
-- +--+-------------+--------------------------+
-- |id|data         |created_at                |
-- +--+-------------+--------------------------+
-- |1 |Data from VM1|2025-11-05 11:39:35.147831|
-- +--+-------------+--------------------------+

SELECT * FROM test2;   -- Должны видеть данные из VM2
-- +--+-------------+--------------------------+
-- |id|data         |created_at                |
-- +--+-------------+--------------------------+
-- |1 |Data from VM2|2025-11-05 11:39:40.663076|
-- +--+-------------+--------------------------+

```

# Горячее реплицирование для высокой доступности на 4 ВМ

## Дополнительная настройка с VM4

### Шаг 1: Настройка физической репликации

```shell
# Создаем пользователя для репликации
sudo -u postgres psql -c "CREATE USER replicator WITH REPLICATION ENCRYPTED PASSWORD 'replica_password';"

# Проверяем настройки в postgresql.conf
# wal_level = replica
# max_wal_senders = 10
# max_replication_slots = 10
# hot_standby = on

# Настраиваем pg_hba.conf
# host replication replicator 192.168.1.0/24 md5

sudo systemctl restart postgresql
```

### На VM4 (горячая реплика):
```shell
# Останавливаем PostgreSQL
sudo systemctl stop postgresql

# Удаляем данные (если есть)
sudo -u postgres rm -rf /var/lib/postgresql/*/main/*

# Создаем базовый бэкап
sudo -u postgres pg_basebackup -h 192.168.1.12 -D /var/lib/postgresql/14/main -U replicator -P -R -S replica_slot_vm4

# Или альтернативный способ:
sudo -u postgres pg_basebackup -h 192.168.1.12 -D /var/lib/postgresql/14/main -U replicator -P -R -X stream

# Запускаем PostgreSQL
sudo systemctl start postgresql
```

### Шаг 2: Создание слота репликации на VM3

```sql
SELECT * FROM pg_create_physical_replication_slot('replica_slot_vm4');
```

### Шаг 3: Настройка recovery.conf (PostgreSQL 12+) или в postgresql.conf

На VM4 создаем файл standby.signal:
```shell
sudo -u postgres touch /var/lib/postgresql/14/main/standby.signal
```

И добавляем в postgresql.conf:
```shell
primary_conninfo = 'host=192.168.1.12 port=5432 user=replicator password=replica_password'
primary_slot_name = 'replica_slot_vm4'
hot_standby = on
```

### Шаг 4: Проверка репликации

```sql
-- На VM3:
SELECT * FROM pg_stat_replication WHERE application_name = 'walreceiver';

-- На VM4:
SELECT pg_is_in_recovery(); -- true
```

## Проблемы и их решения

1. Проблема: Ошибки подключения
   Решение: Проверить настройки pg_hba.conf и firewall
2. Проблема: Конфликты репликации
   Решение:
```sql
-- На реплике
ALTER SUBSCRIPTION sub_name DISABLE;
ALTER SUBSCRIPTION sub_name ENABLE;

-- Или пересоздать подписку
```
3. Проблема: Задержки репликации
   Решение: Мониторинг через:
```sql
SELECT * FROM pg_stat_replication;
SELECT * FROM pg_replication_slots;
```
4. Проблема: Логическая репликация больших таблиц
   Решение: Использовать pg_dump для начальной синхронизации

## Мониторинг и управление

Проверка статуса репликации:
```sql
-- Проверка подписок
SELECT * FROM pg_subscription;

-- Проверка публикаций
SELECT * FROM pg_publication;

-- Проверка слотов репликации
SELECT * FROM pg_replication_slots;

-- Статус физической репликации
SELECT * FROM pg_stat_replication;
```

Управление репликацией:
```sql
-- Приостановка/возобновление подписки
ALTER SUBSCRIPTION sub_name DISABLE;
ALTER SUBSCRIPTION sub_name ENABLE;

-- Обновление подписки
ALTER SUBSCRIPTION sub_name REFRESH PUBLICATION;
```

## Выводы

- Логическая репликация отлично подходит для репликации отдельных таблиц между серверами
- Физическая репликация обеспечивает полную репликацию всей БД для высокой доступности
- Комбинированный подход позволяет создать гибкую архитектуру репликации
- Мониторинг - ключевой аспект поддержания стабильной репликации
- Основные сложности возникли с настройкой сетевого взаимодействия, управлением слотами репликации и обработкой конфликтов при логической репликации.





